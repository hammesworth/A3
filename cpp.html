<!DOCTYPE html>
<html lang="pt-br">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
Â  <title>LaÃ§os e Vetores em C++</title>
Â  <link rel="stylesheet" href="style.css" />
</head>
<body>

<header>
Â  Â  <h1>Explorando while, do while, for e vetores de C++ ğŸ› ï¸</h1>
Â  Â  <p>Um guia para iniciantes e intermediÃ¡rios, aprofundando nos conceitos de repetiÃ§Ã£o e armazenamento de dados.</p>
Â  Â  <nav>
Â  Â  <p><a href="index.html">Ir para o Guia de HTML & CSS</a></p>
Â  Â  <p><a href="xml_git.html">Ir para o Guia de XML & Git</a></p>
Â  Â  <p><a href="cppbasic.html">Ir para o guia bÃ¡sico de C++</a></p>
Â  Â  </nav>
</header>

Â  Â  <main>
Â  <div id="xml-intro">

Â  Â  <section>
Â  Â  Â  <h2 class="subtitle">ğŸ” While</h2>
Â  Â  Â  <p>O comando <code>while</code> (enquanto) Ã© uma estrutura de controle condicional (semelhante ao if), e que repete um bloco de cÃ³digo enquanto sua condiÃ§Ã£o for avaliada como verdadeira. Ã‰ ideal para situaÃ§Ãµes onde o nÃºmero de usos de um determinado bloco de comandos nÃ£o Ã© conhecido de inÃ­cio, como, por exemplo, na validaÃ§Ã£o de entrada de dados do usuÃ¡rio ou na leitura de um arquivo atÃ© o seu final.</p>
      <p>A condiÃ§Ã£o Ã© verificada <strong>antes</strong> da execuÃ§Ã£o do bloco. Se a condiÃ§Ã£o for falsa na primeira verificaÃ§Ã£o, o bloco de cÃ³digo dentro do <code>while</code> nunca serÃ¡ executado.</p>
Â  Â  Â  <pre class="code">
#include &lt;iostream&gt;

int main() {
    int i = 0;
    while (i < 5) {
        cout << i << " ";
        i++; // i aumenta 1 de valor a cada repetiÃ§Ã£o, isso para evitar um loop infinito
    }
    cout << "\n";
    return 0;
}
Â  Â  Â  </pre>
Â  Â  Â  <p><strong>A saÃ­da Ã©:</strong> 0 1 2 3 4</p>
      <p><strong>Aviso:</strong> Ã‰ bom evitar que a variÃ¡vel de controle da condiÃ§Ã£o (neste caso, `i`) seja modificada dentro do <code>while</code>, isso para que, em algum momento, a condiÃ§Ã£o se torne falsa. Caso contrÃ¡rio, o programa entrarÃ¡ em um <strong>loop infinito</strong>.</p>
        <pre class="code">
// Exemplo de loop infinito (NÃ£o Ã© pra fazer isso)
int i = 0;
while (i < 5) {
    cout << "Isso nunca vai parar!\n";
    // 'i' nunca Ã© incrementado, entÃ£o i < 5 serÃ¡ sempre verdade.
}
        </pre>
Â  Â  </section>

Â  Â  <section>
Â  Â  Â  <h2 class="subtitle">ğŸ” Do While</h2>
Â  Â  Â  <p>O comando <code>do while</code> Ã© uma variaÃ§Ã£o do <code>while</code>. A principal diferenÃ§a Ã© que a condiÃ§Ã£o Ã© verificada <strong>apÃ³s</strong> a execuÃ§Ã£o do bloco de cÃ³digo. Isso garante que o bloco seja executado <strong>pelo menos uma vez</strong>, independentemente da condiÃ§Ã£o ser verdadeira ou falsa.</p>
      <p>Ã‰ particularmente Ãºtil para menus de opÃ§Ãµes ou quando se precisa solicitar uma entrada ao usuÃ¡rio e validÃ¡-la em seguida, repetindo o pedido se a entrada for invÃ¡lida. Ã‰ um exemplo esdrÃºxulo, mas serve.</p>
Â  Â  Â  <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int i = 5; // Note que a condiÃ§Ã£o (i < 5) Ã© falsa inicialmente
    do {
        cout << "Executado ao menos uma vez. i = " << i;
        i++;
    } while (i < 5);
    return 0;
}
Â  Â  Â  </pre>
Â  Â  Â  <p><strong>SaÃ­da:</strong> Executado ao menos uma vez. i = 5</p>
      <p>Neste exemplo, mesmo que `i` comece com o valor 5 (o que torna a condiÃ§Ã£o `i < 5` falsa), o texto Ã© impresso uma vez antes que a condiÃ§Ã£o seja checada. E como ela Ã© falsa, ela nÃ£o Ã© executada novamente.</p>
Â  Â  </section>

Â  Â  <section>
Â  Â  Â  <h2 class="subtitle">ğŸ” For</h2>
Â  Â  Â  <p>O comando <code>for</code> Ã© a estrutura de repetiÃ§Ã£o mais comum (para progamadores de verdade) e Ã© ideal quando se sabe o nÃºmero exato de execuÃ§Ãµes do cÃ³digo. Ele Ã© mais compacto e legÃ­vel para esses casos, pois agrupa a inicializaÃ§Ã£o, a condiÃ§Ã£o e o incremento em uma Ãºnica linha.</p>
      <p>A estrutura do <code>for</code> consiste em trÃªs partes, separadas por ponto e vÃ­rgula:</p>
      <ul>
        <li><strong>InicializaÃ§Ã£o:</strong> Executada uma Ãºnica vez no inÃ­cio. Geralmente, declara e inicializa uma variÃ¡vel de controle (ex: `int i = 0`).</li>
        <li><strong>CondiÃ§Ã£o:</strong> Verificada antes de cada execuÃ§Ã£o. Se for verdadeira, o bloco de cÃ³digo Ã© executado.</li>
        <li><strong>Incremento/Decremento:</strong> Executado ao final de cada iteraÃ§Ã£o (ex: `i++` ou `i--`).</li>
      </ul>
Â  Â  Â  <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    //   (inicializaÃ§Ã£o; condiÃ§Ã£o; incremento)
    for (int i = 0;      i < 5;       i++) {
        cout << i << " ";
    }
        cout << "\n";
    return 0;
}
Â  Â  Â  </pre>
Â  Â  Â  <p><strong>SaÃ­da:</strong> 0 1 2 3 4</p>
         <pre class="code">
#include &lt;iostream&gt;
#include &lt;vector&gt; // NecessÃ¡rio para vector
using namespace std;

int main() {
    int numeros[] = {10, 20, 30, 40, 50};
    // Para cada 'numero' na coleÃ§Ã£o 'numeros', faÃ§a:
    for (int numero : numeros) {
        cout << numero << " ";
    }
    cout << "\n";
    return 0;
}
        </pre>
        <p><strong>SaÃ­da:</strong> 10 20 30 40 50</p>
Â  Â  </section>

Â  Â  <section>
Â  Â  Â  <h2 class="subtitle">ğŸ“¦ Vetores (Arrays)</h2>
Â  Â  Â  <p>Um vetor (ou array) Ã© uma estrutura de dados fundamental que armazena uma coleÃ§Ã£o de elementos de tamanho fixo e do mesmo tipo de dado, de forma contÃ­gua na memÃ³ria. O acesso aos elementos Ã© feito por meio de um <strong>Ã­ndice</strong>, que em C++ comeÃ§a em <strong>0</strong>.</p>
      <p>Isso significa que para um vetor de tamanho `N`, os Ã­ndices vÃ¡lidos vÃ£o de `0` a `N-1`. Tentar acessar um Ã­ndice fora desse intervalo (por exemplo, `numeros[3]` em um vetor de 3 elementos) resulta em <strong>comportamento indefinido</strong>, um erro grave que pode corromper dados ou travar o programa.</p>
Â  Â  Â  <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    // Declara e inicializa um vetor de 3 inteiros.
    int numeros[3] = {10, 20, 30};

    // Acessando e imprimindo elementos
    cout << "Elemento no indice 0: " << numeros[0] << "\n";
    cout << "Elemento no indice 1: " << numeros[1] << "\n";
    cout << "Elemento no indice 2: " << numeros[2] << "\n";

    // Modificando um elemento
    numeros[1] = 25;
    cout << "Novo valor no indice 1: " << numeros[1] << "\n";
    
    return 0;
}
Â  Â  Â  </pre>
Â  Â  Â  <p><strong>SaÃ­da:</strong><br>Elemento no indice 0: 10<br>Elemento no indice 1: 20<br>Elemento no indice 2: 30<br>Novo valor no indice 1: 25</p>
Â  Â  Â  <p>TambÃ©m Ã© possÃ­vel declarar o vetor sem uma inicializaÃ§Ã£o explÃ­cita, mas os valores iniciais serÃ£o "lixo" (valores indefinidos da memÃ³ria), a menos que seja um array estÃ¡tico ou global (caso em que sÃ£o inicializados com zero).</p>
Â  Â  Â  <pre class="code">
int notas[5]; // Declara um vetor para 5 inteiros.
notas[0] = 10;  // Atribui um valor ao primeiro elemento.
Â  Â  Â  </pre>
      <p><strong>Alternativa Moderna: `vector`</strong></p>
      <p>Embora os arrays no estilo C sejam fundamentais, o C++ moderno incentiva o uso de <code>vector</code> da Biblioteca PadrÃ£o. `vector` Ã© um contÃªiner dinÃ¢mico que pode crescer e encolher de tamanho, gerencia a memÃ³ria automaticamente e oferece funÃ§Ãµes Ãºteis, como obter o tamanho atual (`.size()`), tornando o cÃ³digo mais seguro e flexÃ­vel.</p>
        <pre class="code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    vector&lt;int&gt; notas = {10, 9, 8};
    notas.push_back(7); // Adiciona um novo elemento ao final

    for (int nota : notas) {
        cout << nota << " ";
    }
    cout << "\nTamanho do vetor: " << notas.size() << "\n";
    return 0;
}
        </pre>
        <p><strong>SaÃ­da:</strong><br>10 9 8 7 <br>Tamanho do vetor: 4</p>
Â  Â  </section>

</div>

</main>

Â  Â  <footer>
Â  Â  Â  <p style="text-align: center; margin-top: 40px;">ğŸ’» Teste os exemplos em um compilador online como o GDB para praticar.</p>
Â  Â  Â  <p>&copy; Lucas Willian</p>
Â  Â  </footer>
Â  </div>
</body>
</html>