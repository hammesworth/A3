<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Fundamentos de Arquitetura Computacional - Guia Completo</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

<header>
    <h1>Fundamentos de Arquitetura Computacional üíª</h1>
    <p>Um guia aprofundado sobre os sistemas de numera√ß√£o, √°lgebra booleana, portas l√≥gicas e prototipagem que constituem a espinha dorsal da computa√ß√£o moderna.</p>
    <nav>
        <p><a href="index.html">Ir para o Guia de HTML & CSS</a></p>
        <p><a href="xml_git.html">Ir para o Guia de XML & Git</a></p>
        <p><a href="cppbasic.html">Ir para o guia b√°sico de C++</a></p>
    </nav>
</header>

<main>
<div id="xml-intro">

    <section>
      <h2 class="subtitle">üî¢ Bases Num√©ricas: A Linguagem das M√°quinas</h2>
      <p>A arquitetura de computadores √© constru√≠da sobre o conceito de sistemas de numera√ß√£o. Enquanto humanos usam a base 10 por conveni√™ncia (provavelmente por termos 10 dedos), as m√°quinas precisam de um sistema que reflita seu estado f√≠sico: a presen√ßa ou aus√™ncia de corrente el√©trica. √â aqui que as diferentes bases entram em jogo.</p>
      <ul>
        <li><strong>Decimal (Base 10):</strong> O sistema posicional que usamos, composto por dez d√≠gitos (0-9). O valor de um d√≠gito depende de sua posi√ß√£o, que corresponde a uma pot√™ncia de 10. Ex: $253 = (2 \times 10^2) + (5 \times 10^1) + (3 \times 10^0)$.</li>
        <li><strong>Bin√°rio (Base 2):</strong> A linguagem nativa e fundamental de todo circuito digital. Utiliza apenas dois d√≠gitos: <strong>0</strong> (desligado, falso, sem tens√£o) e <strong>1</strong> (ligado, verdadeiro, com tens√£o). Cada d√≠gito bin√°rio √© chamado de <strong>bit</strong>.
            <ul>
                <li>Um grupo de 4 bits √© um <strong>nibble</strong>.</li>
                <li>Um grupo de 8 bits forma um <strong>byte</strong>, a unidade b√°sica de armazenamento de dados.</li>
            </ul>
        </li>
        <li><strong>Octal (Base 8):</strong> Utiliza oito d√≠gitos (0-7). Foi historicamente importante em sistemas de computa√ß√£o mais antigos (como os mainframes da IBM e o PDP-8) porque a convers√£o de e para bin√°rio √© trivial: cada d√≠gito octal corresponde exatamente a um grupo de <strong>3 bits</strong>. Em linguagens como C/C++, n√∫meros octais s√£o prefixados com um `0` (ex: `0755`).</li>
        <li><strong>Hexadecimal (Base 16):</strong> O sistema preferido por desenvolvedores para representar dados bin√°rios de forma concisa. Utiliza dezesseis s√≠mbolos: os d√≠gitos 0-9 e as letras A-F para representar os valores de 10 a 15. √â extremamente √∫til para visualizar endere√ßos de mem√≥ria, representar cores (ex: `#FF0000` para vermelho) e em depura√ß√£o de baixo n√≠vel. Cada d√≠gito hexadecimal corresponde a um <strong>nibble</strong> (4 bits). Em programa√ß√£o, o prefixo `0x` √© comum (ex: `0xFF`).</li>
      </ul>
    </section>

    <section>
      <h2 class="subtitle">üîÑ Convers√£o Detalhada entre Bases</h2>
      <p>A habilidade de traduzir valores entre essas bases √© crucial para qualquer profissional de tecnologia.</p>

      <h3 class="sub-subtitle">Decimal ‚ÜîÔ∏è Outras Bases</h3>
      <p><strong>Decimal para Bin√°rio (Divis√µes por 2):</strong></p>
      <pre class="code">
Exemplo: Converter 181‚ÇÅ‚ÇÄ para bin√°rio.

181 √∑ 2 = 90, resto 1
 90 √∑ 2 = 45, resto 0
 45 √∑ 2 = 22, resto 1
 22 √∑ 2 = 11, resto 0
 11 √∑ 2 = 5,  resto 1
  5 √∑ 2 = 2,  resto 1
  2 √∑ 2 = 1,  resto 0
  1 √∑ 2 = 0,  resto 1

Lendo os restos de baixo para cima: 10110101‚ÇÇ.
      </pre>

      <p><strong>Bin√°rio para Decimal (Soma das Pot√™ncias de 2):</strong></p>
      <pre class="code">
Exemplo: Converter 10110101‚ÇÇ para decimal.

(1√ó2‚Å∑) + (0√ó2‚Å∂) + (1√ó2‚Åµ) + (1√ó2‚Å¥) + (0√ó2¬≥) + (1√ó2¬≤) + (0√ó2¬π) + (1√ó2‚Å∞)
= 128 + 0 + 32 + 16 + 0 + 4 + 0 + 1
= 181‚ÇÅ‚ÇÄ.
      </pre>

      <p><strong>Decimal para Octal (Divis√µes por 8):</strong></p>
       <pre class="code">
Exemplo: Converter 181‚ÇÅ‚ÇÄ para octal.

181 √∑ 8 = 22, resto 5
 22 √∑ 8 = 2,  resto 6
  2 √∑ 8 = 0,  resto 2

Lendo de baixo para cima: 265‚Çà.
       </pre>

      <h3 class="sub-subtitle">Convers√µes R√°pidas (Bin√°rio ‚ÜîÔ∏è Octal/Hex)</h3>
      <p>Essas s√£o as convers√µes mais r√°pidas e √∫teis no dia a dia da programa√ß√£o de baixo n√≠vel, pois n√£o requerem passagem pela base decimal.</p>

      <p><strong>Bin√°rio para Octal (Grupos de 3 bits):</strong></p>
      <pre class="code">
Exemplo: Converter 10110101‚ÇÇ para octal.

1. Agrupe de 3 em 3, da direita para a esquerda (complete com zeros se necess√°rio):
   010  110  101

2. Converta cada grupo:
   010‚ÇÇ = 2‚Çà
   110‚ÇÇ = 6‚Çà
   101‚ÇÇ = 5‚Çà

Resultado: 265‚Çà.
      </pre>

      <p><strong>Bin√°rio para Hexadecimal (Grupos de 4 bits):</strong></p>
      <pre class="code">
Exemplo: Converter 10110101‚ÇÇ para hexadecimal.

1. Agrupe de 4 em 4, da direita para a esquerda:
   1011  0101

2. Converta cada grupo (nibble):
   1011‚ÇÇ = 11‚ÇÅ‚ÇÄ = B‚ÇÅ‚ÇÜ
   0101‚ÇÇ =  5‚ÇÅ‚ÇÄ = 5‚ÇÅ‚ÇÜ

Resultado: B5‚ÇÅ‚ÇÜ.
      </pre>
    </section>

    <section>
      <h2 class="subtitle">‚öôÔ∏è Portas L√≥gicas e √Ålgebra de Boole</h2>
      <p>Portas l√≥gicas s√£o circuitos, geralmente compostos por transistores, que executam uma opera√ß√£o da <strong>√Ålgebra Booleana</strong>. Esta √°lgebra, criada por George Boole, √© a matem√°tica por tr√°s da l√≥gica digital. Ao combinar estas portas, podemos criar circuitos complexos que realizam desde somas (somadores) at√© o processamento de instru√ß√µes em uma CPU.</p>
      
      <p><strong>Porta AND (E / Conjun√ß√£o L√≥gica):</strong> A sa√≠da √© 1 se, e somente se, <strong>todas</strong> as entradas forem 1. Express√£o: $Q = A \cdot B$ ou $Q = A \land B$.</p>
      <pre class="code">Tabela Verdade - AND
A | B | Q
--|---|--
0 | 0 | 0
0 | 1 | 0
1 | 0 | 0
1 | 1 | 1</pre>

      <p><strong>Porta OR (OU / Disjun√ß√£o L√≥gica):</strong> A sa√≠da √© 1 se <strong>qualquer</strong> das entradas for 1. Express√£o: $Q = A + B$ ou $Q = A \lor B$.</p>
      <pre class="code">Tabela Verdade - OR
A | B | Q
--|---|--
0 | 0 | 0
0 | 1 | 1
1 | 0 | 1
1 | 1 | 1</pre>

      <p><strong>Porta NOT (N√ÉO / Inversor):</strong> A sa√≠da √© o inverso da entrada √∫nica. Express√£o: $Q = \overline{A}$ ou $Q = \neg A$.</p>
      <pre class="code">Tabela Verdade - NOT
A | Q
--|--
0 | 1
1 | 0</pre>

      <p><strong>Porta NAND (N√ÉO-E):</strong> √â a nega√ß√£o de uma porta AND. √â uma <strong>porta universal</strong>, significando que qualquer outra porta pode ser constru√≠da usando apenas portas NAND. Express√£o: $Q = \overline{A \cdot B}$.</p>
      <pre class="code">Tabela Verdade - NAND
A | B | Q
--|---|--
0 | 0 | 1
0 | 1 | 1
1 | 0 | 1
1 | 1 | 0</pre>

      <p><strong>Porta NOR (N√ÉO-OU):</strong> √â a nega√ß√£o de uma porta OR. Tamb√©m √© uma <strong>porta universal</strong>. Express√£o: $Q = \overline{A + B}$.</p>
      <pre class="code">Tabela Verdade - NOR
A | B | Q
--|---|--
0 | 0 | 1
0 | 1 | 0
1 | 0 | 0
1 | 1 | 0</pre>

      <p><strong>Porta XOR (OU Exclusivo):</strong> A sa√≠da √© 1 se as entradas forem <strong>diferentes</strong>. √â fundamental para circuitos aritm√©ticos. Express√£o: $Q = A \oplus B$.</p>
      <pre class="code">Tabela Verdade - XOR
A | B | Q
--|---|--
0 | 0 | 0
0 | 1 | 1
1 | 0 | 1
1 | 1 | 0</pre>
    </section>

    <section>
        <h2 class="subtitle">üîå Protoboards: Da Teoria √† Pr√°tica</h2>
        <p>A protoboard (ou breadboard) √© uma placa de prototipagem que permite montar e testar circuitos sem solda. √â a ponte entre o diagrama esquem√°tico e o circuito funcional.</p>
        <p>A sua estrutura interna √© projetada para m√°xima efici√™ncia:</p>
        <ul>
            <li><strong>Tiras de Terminais:</strong> S√£o as fileiras horizontais no corpo central. Todos os 5 furos em uma mesma fileira (at√© a divis√£o central) est√£o eletricamente conectados. S√£o usadas para conectar os terminais dos componentes (resistores, LEDs, etc).</li>
            <li><strong>Divis√£o Central:</strong> O canal no meio da protoboard serve para acomodar Circuitos Integrados (CIs) no formato DIP (Dual In-line Package), de modo que os pinos de cada lado do CI fiquem em tiras de terminais separadas, sem causar curto-circuito.</li>
            <li><strong>Tiras de Barramento (Alimenta√ß√£o):</strong> S√£o as longas colunas verticais nas laterais, marcadas com linhas vermelhas (+) e azuis/pretas (-). Todos os furos em uma mesma coluna est√£o conectados, servindo para distribuir a tens√£o de alimenta√ß√£o (VCC) e o terra (GND) por todo o circuito de forma organizada.</li>
        </ul>
        <p><strong>Boas Pr√°ticas de Prototipagem:</strong></p>
        <ol>
            <li><strong>Planeje Primeiro:</strong> Sempre comece com um diagrama esquem√°tico do seu circuito.</li>
            <li><strong>Use Cores:</strong> Adote uma conven√ß√£o de cores para os fios (jumpers). Ex: vermelho para VCC, preto para GND, outras cores para sinais. Isso facilita a depura√ß√£o.</li>
            <li><strong>Mantenha Organizado:</strong> Corte os fios e os terminais dos componentes no comprimento adequado para que fiquem rentes √† placa. Isso evita contatos acidentais e torna o circuito mais leg√≠vel.</li>
            <li><strong>Verifique Tudo:</strong> Antes de ligar a alimenta√ß√£o, revise todas as conex√µes para garantir que correspondem ao seu diagrama. Um erro pode danificar permanentemente seus componentes.</li>
        </ol>
    </section>

</div>

</main>

    <footer>
        <p style="text-align: center; margin-top: 40px;">üí° Para solidificar este conhecimento, experimente montar um somador de 1 bit usando portas l√≥gicas em um simulador como o Tinkercad ou o Logisim. Isso conectar√° a teoria da √Ålgebra Booleana com a pr√°tica dos circuitos digitais.</p>
        <p>&copy; Lucas Willian</p>
    </footer>

</body>
</html>